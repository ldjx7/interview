MySQL:

Redis:

RocketMQ:

Golang:

1.GMP调度模型

G: goroutine

- go协程，主要包含协程执行的一些栈信息，运行状态，任务函数等
- go关键字创建协程时，会将创建的G放至P的local队列中，如果所有P的local队列都满了，则会把该G放置在全局队列中
- 对应runtime.g结构体 包含

M: machine

- 工作线程，是调度系统的真正执行者
- 优先从关联的P-local队列中获取一个可运行的G来执行
- 如果P的队列为空，则会从全局队列中获取可运行的G来执行
- 如果全局队列为空，则会从其它M绑定的P队列中偷取一半的G
- go程序启动时默认的M的最大数量为 10000
- runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量
- 当某个M阻塞了，会创建新得的M
- 对应runtime.m结构体 包含正在运行的G，正在运行代码的P，之前使用的P等

P: processor

- processor处理器，它包含了运行 goroutine 的资源
- 主要用于处理M和G的关系，M想要执行groutine，必须先获取P，p中包含了可运行G的队列
- P的个数在程序启动时决定，默认等同与CPU的核数，通过 runtime.GOMAXPROCS() 设置P的个数
- 对应runtime.p结构体 包含G队列，下一个可执行的G，调度的M等信息

M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行

调度策略

复用线程：避免频繁的创建、销毁线程，而是对线程的复用。

work stealing机制
当M没有可运行的 G 时，尝试从其他线程M绑定的 P 偷取一半的G过来，而不是销毁线程。

work stealing机制触发：当前M线程的P本地队列中没有可运行的G时 并且 全局队列G中也没有可运行的G时，则会执行workstealing机制.

即：本地队列→全局队列→窃取

hand off 机制

当M阻塞时，M释放绑定的 P（MP分离），把 P 转移给其他空闲的线程执行。

抢占

在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 执行的时间不能超过 10ms，防止其他 goroutine 被饿死。

阻塞的两种情况

- 用户态阻塞/唤醒
  - 例如网络IO、阻塞式channel、sleep等场景(简单来说就是CPU这时候对于这个协程没有事情要做)，对于这类阻塞会将G暂时挂起到某一临时等待队列中，待阻塞结束后重新寻找P放入。

- 系统调用阻塞
  - M 执行某一个 G 时，如果发生系统调用或则其余阻塞操作，M 会阻塞，如果当前有 G 在执行，runtime 会将这个 MP 进行分离，如果有空闲的M就用或者是从线程池中取，如果没有就创建一个新的M 来服务于这个 P；
  - 当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中

拓展

判定阻塞的原理：

go程序启动时会首先创建一个特殊的内核线程 sysmon，用来监控和管理，其内部是一个循环：

记录所有 P 的 G 任务的计数 schedtick，schedtick会在每执行一个G任务后递增

如果检查到 schedtick 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记

然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G

如果没有遇到非内联函数 调用的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS=1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！

2.GC

第一阶段：gc开始，std(stop the world)

初始所有内存都是白色的，进入标记队列就是灰色

1. stop the world
2. 每个processor启动一个mark worker goroutine用于标记（用于第二阶段工作）
3. 启动gc write barrier（记录一下后续在进行marking时被修改的指针）
4. 找到所有roots（stack, heap, global vars）并加入标记队列
5. start the world，进入第二阶段

第二阶段：marking，start the world

1. 从标记队列里面取出对象，标记为黑色（不能GC）
2. 然后检查是否有是指向另一个对象，是，则加入标记队列
3. golang中分配对象会根据是否是指针分别放到不同的span中，根据这个如果span是指针span，那么就需要继续scan下一个对象，否则停止该路scan，取队列中下一个对象继续scan
4. 在扫描过程中，如果用户代码修改对象，那么会触发写屏障，将对象标记为灰色，并加入单独的扫描队列中

注意：

1. 这个阶段是和用户的程序并发一起运行的
2. 所有进入队列中的对象逻辑上就认为是灰色的
3. 从队列中出来的需要scan的对象被标记为黑色，将bitmap中对应的gcmarkBits设为1

第三阶段：处理marking过程中修改的指针，stop the world

stop the world，将gc write barrier记录的所有修改的指针也加入标记队列进行一轮标记

注意这个阶段不是和用户程序并行的

扫描完了以后start the world

第四阶段：sweep

到这一阶段，所有内存要么是黑色的要么是白色的，清楚所有白色的即可

golang的内存管理结构中有一个bitmap区域，其中可以标记是否“黑色”

GC触发条件

1. 内存大小阈值， 内存达到上次gc后的2倍
2. 达到定时时间 ，2m interval

阈值是由一个gc percent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。

并发回收实现原理

赋值器修改对象图，导致某一黑色对象引用白色对象；
从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。

解决办法：

黑色对象引用某个白色对象后，将白色对象“变灰”，需要后续扫描
新分配的对象直接设为“黑色”

实现原理：
内存屏障（Memory Barrier）保障了代码描述中对内存的操作顺序，既不会在编译期被编译器进行调整，也不会在运行时被 CPU 的乱序执行所打乱， 是一种语言与语言用户间的契约。
在开始gc是启动内存写屏障，所有修改对象的操作加入一个写屏障，通知gc将受影响的对象变为灰色；
然后在第一次gc后，重新对gc过程中变灰的对象再扫描一次

3.内存逃逸

一般来说，局部变量会在函数返回后被销毁，因此被返回的引用就成为了没有指针指向的引用，程序会进入未知状态                                                                                                          但这在go中是安全的，go语言会对每个局部变量进行逃逸分析，如果发生局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上，即使释放函数，其内容也不会受影响
概念： go在 编译时 进行逃逸分析，他会决定一个对象放在栈上还是堆上，不逃逸的放栈上，可能逃逸的放堆上
目的：尽可能将变量分配到栈上
方式： 编译器可以证明变量在函数返回后不再被引用，才会分配到栈上，否则分配到堆上
在栈上分配（静态内存分配），一般由系统进行申请和释放，eg.函数的入参、局部变量、返回值等，每个函数都会分配一个栈帧，在函数运行结束后进行销毁
在堆上分配（动态内存分配），在函数运行结束后仍然可以使用，如果要回收掉，需要进行GC,带来额外的性能开销
编程语言不断优化GC算法，主要目的是为了减少GC带来的额外性能开销，变量一旦逃逸会导致性能开销变大

逃逸机制：

编译器会根据变量是否被外部引用来决定是否逃逸

1.函数没有外部引用，优先放到栈中

2.函数外部存在引用，放在堆中

3.栈上放不下，必定放到堆中

逃逸分析就是由编译器决定哪些变量放在栈中，哪些放在堆中，通过编译参数-gcflag=-m可以查看编译过程中的逃逸分析

可能的场景：

通过go build -gcflags=-m main.go查看逃逸情况

1.指针逃逸

函数返回值为局部变量的指针，函数虽然退出了，但因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上

    package main
    func escape1()* int{
        var a int = 1
        return &a
    }
    func main(){
        escape1()
    }

2.栈空间不足

    package main
    
    func escape2() {
    	s := make([]int, 0, 10000)
    	for index, _ := range s {
    		s[index] = index
    	}
    }
    func main() {
    	escape2()
    }

3.变量大小不确定

    package main
    
    func escape3() {
    	number := 10
    	s := make([]int, number)
    	for i := 0; i < len(s); i++ {
    		s[i] = i
    	}
    }
    func main() {
    	escape3()
    }

 编译期无法确定slice的长度，这种情况为了保证内存的安全，编译期也会触发逃逸，在堆上进行内存分配

直接s:=make([]int,10)不会发生逃逸

4.动态类型

动态类型就是编译期间不确定参数的类型、参数的长度也不确定的情况下就会发生逃逸

空接口interface{}可以表示任意的类型，如果函数参数为interface{},编译期间很难确定其参数的具体类型，也会发生逃逸

    package main
    
    import "fmt"
    
    func escape4() {
    	fmt.Println(1111)
    }
    func main() {
    	escape4()
    }

5.闭包引用对象

闭包函数中局部变量i在后续函数是继续使用的，编译器将其分配到堆上

    package main
    
    func escape5() func() int {
    	var i int = 1
    	return func() int {
    		i++
    		return i
    	}
    }
    func main() {
    	escape5()
    }

总结：

1.栈上分配内存比堆中分配内存效率更高

2.栈上分配的内存不需要GC处理，而堆需要

3.逃逸分析目的是决定内存分配地址是栈还是堆

4.逃逸分析在编译阶段完成

无论变量大小，只要是指针变量都会在堆上分配，所以对于小变量使用传值（而不是传指针）效率更高


面试相关：
2.19面试题：

1.make和new的区别

2.map是否并发安全

3.tcp和udp的区别，应用场景。三次握手，四次挥手

4.redis的数据类型

5.redis的持久化方式

6.mysql的索引匹配(最左匹配原则)：A，B两个字段创建联合索引，查询条件为 B='' and A=''，问能否走索引？

7.slice和数组的不同

8.是否了解GMP，讲一讲

9.对channel有了解吗？讲一下有缓冲的channel和无缓冲channel有什么不同

10.说一说 进程，线程，协程的关系。其中还问到了不同进程间是如何通信的？

11.项目中(线上)遇到过哪些印象深刻的问题？

12.对IO模型是否有了解？poll，epoll等  回答：不了解。







